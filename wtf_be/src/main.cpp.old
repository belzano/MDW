#include "platform.h"
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include <signal.h>
#include <pthread.h>

#include <microhttpd.h>

#include "ServiceInvocator.hpp"

using std::map;
using std::string;

#define PAGE "<html><head><title>Error</title></head><body>Bad data</body></html>"

static int shouldNotExit = 1;

//////////////////////////////////////////////////////////////////////

static int send_bad_response( struct MHD_Connection *connection)
{
    static char *bad_response = (char *)PAGE;
    int bad_response_len = strlen(bad_response);
    
    struct MHD_Response *response;
	response = MHD_create_response_from_data (bad_response_len,
											  bad_response,
                                              1 /*must_free*/,
                                              0 /*must_copy*/);
    if (response == 0)
        return MHD_NO;
  
    int ret = MHD_queue_response (connection, MHD_HTTP_OK, response);
    MHD_destroy_response (response);
    return ret;
}

////////////////////////////////////////////////////////////////////

// TODO should be part of invocator
static int get_url_args(void *cls, MHD_ValueKind /*kind*/,
                    const char *key , const char* value)
{
    map<string, string> * url_args = static_cast<map<string, string> *>(cls);

    if (url_args->find(key) == url_args->end())
    {
         if (!value)
             (*url_args)[key] = "";
         else 
            (*url_args)[key] = value;
    }
    return MHD_YES;
}
     
//////////////////////////////////////////////////////////////////////
    
// Data kept per request.
struct QueryContext
{
	std::vector<char> data;

  // Post processor handling form data (IF this is a POST request).
  struct MHD_PostProcessor *pp;

  // URL to serve in response to this POST (if this request was a 'POST')
  const char *post_url;
};

////////////////////////////////////////////////////////////////////

static int
post_iterator (void *cls,
				enum MHD_ValueKind /*kind*/,
				const char *key,
				const char */*filename*/,
				const char */*content_type*/,
				const char */*transfer_encoding*/,
				const char *data, 
				uint64_t off, 
				size_t size)
{
    printf ("post_iterator\n");	
	
	struct QueryContext *request = (QueryContext*) cls;

	if (0 == strcmp ("DONE", key))
		return MHD_YES;
     
	if (size + off > request->data.size())
		request->data.reserve(size + off);
    
	std::copy( data, data + size, request->data.begin() + off);
	
	return MHD_YES;
}
    
//////////////////////////////////////////////////////////////////////
   
 // Callback called upon completion of a request.
static void
request_completed_callback (void* /*cls*/,
			    struct MHD_Connection* /*connection*/,
			    void **con_cls,
			    enum MHD_RequestTerminationCode /*toe*/)
{
    printf ("request_completed_callback\n");	
	
  struct QueryContext *request = (QueryContext*) *con_cls;

  if (NULL == request)
    return;
  if (NULL != request->pp)
    MHD_destroy_post_processor (request->pp);
  free (request);
  con_cls = NULL;
}    
     
//////////////////////////////////////////////////////////////////////
  
/**
 * Main MHD callback for handling requests.
 *
 * @param cls argument given together with the function
 *        pointer when the handler was registered with MHD
 * @param connection handle identifying the incoming connection
 * @param url the requested url
 * @param method the HTTP method used ("GET", "PUT", etc.)
 * @param version the HTTP version string (i.e. "HTTP/1.1")
 * @param upload_data the data being uploaded (excluding HEADERS,
 *        for a POST that fits into memory and that is encoded
 *        with a supported encoding, the POST data will NOT be
 *        given in upload_data and is instead available as
 *        part of MHD_get_connection_values; very large POST
 *        data *will* be made available incrementally in
 *        upload_data)
 * @param upload_data_size set initially to the size of the
 *        upload_data provided; the method must update this
 *        value to the number of bytes NOT processed;
 * @param ptr pointer that the callback can set to some
 *        address and that will be preserved by MHD for future
 *        calls for this request; since the access handler may
 *        be called many times (i.e., for a PUT/POST operation
 *        with plenty of upload data) this allows the application
 *        to easily associate some request-specific state.
 *        If necessary, this state can be cleaned up in the
 *        global "MHD_RequestCompleted" callback (which
 *        can be set with the MHD_OPTION_NOTIFY_COMPLETED).
 *        Initially, <tt>*con_cls</tt> will be NULL.
 * @return MHS_YES if the connection was handled successfully,
 *         MHS_NO if the socket must be closed due to a serios
 *         error while handling the request
 */         
static int answer_to_connection(void */*cls*/,
						struct MHD_Connection *connection,
						const char *url,
						const char *method,
						const char */*version*/,
						const char *upload_data, 
						size_t *upload_data_size, 
						void **con_cls)
{   

    printf ("answer_to_connection\n");	
	
    std::string responseBuffer;

    if (0 == strcmp (method, "GET"))
    {
		// decode url args
		map<string, string> url_args;	
		if (MHD_get_connection_values (connection, MHD_GET_ARGUMENT_KIND, get_url_args, &url_args) < 0)
		{
			return send_bad_response(connection);
		}

		WTF::ServiceInvocator invocator;
		invocator.loadServiceLibraries();
		invocator.invoke(url, url_args, responseBuffer);
	}
	else if (0 == strcmp (method, "POST"))
    {   
		struct QueryContext *request = (QueryContext*) *con_cls;
		if (NULL == request)
		{
			request = (QueryContext*) calloc (1, sizeof (struct QueryContext));
			if (NULL == request)
			{
				fprintf (stderr, "calloc error: %s\n", strerror (errno));
				return MHD_NO;
			}
			*con_cls = request;
	
			request->pp = (MHD_PostProcessor*)
							 MHD_create_post_processor (connection, 1024, 
														&post_iterator, request);
			if (NULL == request->pp)
			{
				fprintf (stderr, "Failed to setup post processor for `%s'\n", url);
				return MHD_NO; /* internal error */
			}
			return MHD_YES;
		}
  			   
		/* evaluate POST data */
		MHD_post_process (request->pp, upload_data,*upload_data_size);
		
		if (0 != *upload_data_size)
		{
			*upload_data_size = 0;
			return MHD_YES;
		}
      
		/* done with POST data, serve response */
		MHD_destroy_post_processor(request->pp);
		request->pp = NULL;
		
		if (NULL != request->post_url)
			url = request->post_url;
	
		// decode url args
		map<string, string> url_args;
		
		WTF::ServiceInvocator invocator;
		invocator.loadServiceLibraries();
		invocator.invoke(url, url_args, responseBuffer);		
    }	
	else
	{
       return MHD_NO; 
	}

    *con_cls = NULL; /* reset when done */
    
	// convert response string message to char*
    char *me = (char *)malloc (responseBuffer.size() + 1);
    // Check successful allocation
    if (me == 0)
        return MHD_NO;
    strncpy(me, responseBuffer.c_str(), responseBuffer.size() + 1);
    
    struct MHD_Response* response 
			= MHD_create_response_from_data (strlen (me), me,
                                             1 /*must_free*/, 
                                             0 /*must_copy*/);
    if (response == 0)
    {
        free (me);
        return MHD_NO;
    }

    MHD_add_response_header(response, "Content-Type", "text");
    
    int resultCode = MHD_queue_response (connection, MHD_HTTP_OK, response);
    
    MHD_destroy_response (response);
    
    return resultCode;
}

//////////////////////////////////////////////////////////////////////

void handle_term(int signo)
{
	std::cout << "Caught signal " << signo << ": Stopping soon." << std::endl;
    shouldNotExit = 0;
}

//////////////////////////////////////////////////////////////////////

void* http(void *arg)
{
    int *port = (int *)arg;
    struct MHD_Daemon *d;
    
	int daemon_opts = MHD_USE_SELECT_INTERNALLY
					| MHD_USE_DEBUG 
					| MHD_USE_POLL
					| MHD_USE_THREAD_PER_CONNECTION;
					
    if (*port == 8080)
    {
					
    d = MHD_start_daemon (daemon_opts, *port, NULL, NULL,
						  & answer_to_connection, 
						  (void*) PAGE,  
                          MHD_OPTION_END);
	}
	else
	{
	d = MHD_start_daemon (daemon_opts, *port, NULL, NULL, 
						& answer_to_connection, (void*) PAGE, 
						MHD_OPTION_NOTIFY_COMPLETED, &request_completed_callback, NULL,
						MHD_OPTION_END);                        
    }                   
                        
    if (d == 0)
    {
		printf ("Start Daemon returned 0\n");
        return 0;
    }
    
    printf ("Daemon started OK\n");
    
    while(shouldNotExit)
    {
        sleep(1);
    }
    
    MHD_stop_daemon (d);
    return 0;
}

////////////////////////////////////////////////////////////

int main (int argc, char *const *argv)
{

    if (argc != 2){
        printf ("%s PORT\n", argv[0]);
        exit(1);
    }
    int port = atoi(argv[1]);
    
    // Hook sigterm
    printf ("Hooking SIGTERM\n");
    signal(SIGTERM, handle_term);
    
    
    // Create thread
    pthread_t  thread;
    if ( 0 != pthread_create(&thread, 0 , http, &port))
    {
		printf ("Daemon thread creation failed\n");	
        exit(1);
    }
    
    printf ("Daemon Thread creation OK. Waiting for SIGTERM... \n");
    pthread_join(thread, 0);
    return 0;
}
